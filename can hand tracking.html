<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;500;700&family=Rajdhani:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --stark-blue: #00f2ff;
            --stark-blue-dim: rgba(0, 242, 255, 0.4);
            --hologram-blue: #0077ff;
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --bg-dark: #020408;
            --bg-deep: #0a1120;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            outline: none;
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background: radial-gradient(circle at center, var(--bg-deep) 0%, var(--bg-dark) 100%);
            overflow: hidden;
            color: #fff;
            height: 100vh;
        }

        /* Subtle Grid Background */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(rgba(0, 242, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 242, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            mask-image: radial-gradient(circle at center, black 40%, transparent 100%);
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- STARK PANELS --- */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow:
                0 4px 30px rgba(0, 0, 0, 0.5),
                inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        /* Video Feed - Circular/Holographic */
        #video-container {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            /* Circular */
            overflow: hidden;
            z-index: 100;
            border: 2px solid var(--stark-blue-dim);
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.1);
        }

        /* Rotating Ring around video */
        #video-container::after {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border-radius: 50%;
            border: 2px dashed var(--stark-blue-dim);
            animation: spin-slow 20s linear infinite;
            z-index: -1;
            pointer-events: none;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.9;
            filter: contrast(1.1) brightness(1.1) sepia(0.2) hue-rotate(180deg);
            /* Blue tint */
        }

        #handCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
            z-index: 101;
            border-radius: 50%;
        }

        #hand-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 4px;
            z-index: 102;
            pointer-events: none;
            opacity: 0;
            /* Hide by default, show on active */
            transition: opacity 0.3s;
        }

        #hand-indicator.active {
            opacity: 1;
        }

        .hand-dot {
            width: 6px;
            height: 6px;
            background: var(--stark-blue);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--stark-blue);
        }

        #camera-status {
            display: none;
            /* Minimalist - hide text status unless error */
        }

        /* --- CONTROL PANEL (ARC REACTOR STYLE) --- */
        .control-panel {
            position: fixed;
            top: 40px;
            left: 40px;
            padding: 30px;
            z-index: 100;
            width: 320px;
        }

        .panel-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 25px;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 15px;
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
        }

        .panel-title::before {
            content: '';
            width: 12px;
            height: 12px;
            background: var(--stark-blue);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--stark-blue);
        }

        .section-label {
            font-size: 10px;
            color: var(--stark-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            opacity: 0.8;
            font-weight: 600;
        }

        /* Circular Buttons Grid */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
            justify-items: center;
        }

        .template-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.01));
            border: 1px solid rgba(0, 242, 255, 0.2);
            color: var(--stark-blue);
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .template-btn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            border: 1px dashed rgba(0, 242, 255, 0.3);
            opacity: 0;
            transition: all 0.4s;
            animation: spin-slow 10s linear infinite;
        }

        .template-btn i {
            font-size: 20px;
            font-style: normal;
            z-index: 2;
        }

        .template-btn:hover {
            transform: scale(1.15);
            border-color: var(--stark-blue);
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.4);
            background: rgba(0, 242, 255, 0.1);
        }

        .template-btn:hover::before {
            opacity: 1;
            border-color: var(--stark-blue);
        }

        .template-btn.active {
            background: var(--stark-blue);
            color: #000;
            border-color: var(--stark-blue);
            box-shadow: 0 0 30px var(--stark-blue);
        }

        .template-btn.active::before {
            opacity: 0.5;
        }

        /* Tooltip style for button names */
        .template-btn span {
            position: absolute;
            bottom: -20px;
            font-size: 9px;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #fff;
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
            width: auto;
        }

        .template-btn:hover span {
            opacity: 0.8;
        }

        /* Color Slider (Arc) - Simplified to bar for now */
        .color-picker-wrapper {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .color-input {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .color-input::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
            padding: 0;
        }

        .color-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-presets {
            display: flex;
            gap: 8px;
        }

        .color-preset {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            opacity: 0.6;
        }

        .color-preset:hover {
            transform: scale(1.5);
            opacity: 1;
        }

        .color-preset.active {
            transform: scale(1.5);
            opacity: 1;
            box-shadow: 0 0 10px currentColor;
        }

        /* Slider */
        .scale-slider-container {
            margin-top: 30px;
        }

        .scale-slider {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            appearance: none;
        }

        .scale-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #000;
            border: 2px solid var(--stark-blue);
            box-shadow: 0 0 10px var(--stark-blue);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .scale-slider::-webkit-slider-thumb:hover {
            transform: scale(1.5);
            background: var(--stark-blue);
        }

        /* Gesture Info - Right Side Panel */
        .gesture-info {
            position: fixed;
            top: 50%;
            right: 40px;
            transform: translateY(-50%);
            text-align: right;
            z-index: 90;
        }

        .gesture-value {
            font-family: 'Exo 2', sans-serif;
            font-size: 64px;
            font-weight: 200;
            color: #fff;
            letter-spacing: -2px;
            line-height: 1;
            text-shadow: 0 0 20px rgba(0, 242, 255, 0.3);
        }

        .gesture-label {
            font-size: 12px;
            color: var(--stark-blue);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-top: 5px;
            border-top: 1px solid var(--stark-blue-dim);
            display: inline-block;
            padding-top: 5px;
        }

        .particle-count {
            position: fixed;
            bottom: 40px;
            left: 40px;
            font-family: 'Rajdhani', monospace;
            font-size: 14px;
            color: var(--stark-blue);
            opacity: 0.7;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.8s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .arc-loader {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 2px solid rgba(0, 242, 255, 0.1);
            border-top-color: var(--stark-blue);
            border-bottom-color: var(--stark-blue);
            animation: spin 1.5s linear infinite;
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.2);
            position: relative;
        }

        .arc-loader::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border-radius: 50%;
            border: 2px solid var(--hologram-blue);
            border-left-color: transparent;
            border-right-color: transparent;
            animation: spin-reverse 1s linear infinite;
        }

        .loading-text {
            margin-top: 30px;
            font-family: 'Exo 2', sans-serif;
            letter-spacing: 3px;
            font-size: 12px;
            color: var(--stark-blue);
            animation: pulse 2s infinite;
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes spin-slow {
            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes spin-reverse {
            100% {
                transform: rotate(-360deg);
            }
        }

        @keyframes pulse {
            50% {
                opacity: 0.5;
            }
        }

        /* Entry Animation (Jarvis Assemble) */
        body.stark-active .glass-panel,
        body.stark-active #video-container,
        body.stark-active .gesture-info {
            animation: slide-in 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }

        .glass-panel,
        #video-container,
        .gesture-info {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }

        @keyframes slide-in {
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
    </style>
</head>

<body>
    <div class="loading-overlay" id="loading">
        <div class="arc-loader"></div>
        <div class="loading-text" id="loadingText">INITIALIZING JARVIS PROTOCOL...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="video-container">
        <video id="video" playsinline autoplay muted></video>
        <canvas id="handCanvas"></canvas>
        <div id="hand-indicator">
            <div class="hand-dot" id="left-hand" title="Left Hand"></div>
            <div class="hand-dot" id="right-hand" title="Right Hand"></div>
        </div>
        <div id="camera-status">Initializing camera...</div>
    </div>

    <div class="control-panel glass-panel">
        <div class="panel-title">Particle Core</div>

        <div class="section">
            <div class="section-label">SELECT CONFIGURATION</div>
            <div class="template-grid">
                <button class="template-btn active" data-template="heart">
                    <i>♥</i>
                    <span>HEART</span>
                </button>
                <button class="template-btn" data-template="flower">
                    <i>✾</i>
                    <span>FLOWER</span>
                </button>
                <button class="template-btn" data-template="saturn">
                    <i>♄</i>
                    <span>SATURN</span>
                </button>
                <button class="template-btn" data-template="buddha">
                    <i>∞</i>
                    <span>ZEN</span>
                </button>
                <button class="template-btn" data-template="firework">
                    <i>✷</i>
                    <span>BURST</span>
                </button>
                <button class="template-btn" data-template="star">
                    <i>★</i>
                    <span>NOVA</span>
                </button>
            </div>
        </div>

        <div class="section">
            <div class="section-label">PARTICLE WAVELENGTH</div>
            <div class="color-picker-wrapper">
                <input type="color" class="color-input" id="colorPicker" value="#00f2ff">
                <div class="color-presets">
                    <div class="color-preset active" style="background: #00f2ff" data-color="#00f2ff"></div>
                    <div class="color-preset" style="background: #0077ff" data-color="#0077ff"></div>
                    <div class="color-preset" style="background: #ff0055" data-color="#ff0055"></div>
                    <div class="color-preset" style="background: #ffcc00" data-color="#ffcc00"></div>
                </div>
            </div>
        </div>

        <div class="section scale-slider-container">
            <div class="section-label">FIELD DENSITY</div>
            <input type="range" class="scale-slider" id="scaleSlider" min="0.3" max="3" step="0.1" value="1">
            <div class="help-text" style="color:var(--stark-blue-dim); margin-top:10px; font-size:9px;">
                // GESTURE OVERRIDE ENABLED
            </div>
        </div>
    </div>

    <div class="gesture-info">
        <div class="gesture-value" id="scaleValue">1.0x</div>
        <div class="gesture-label">Particle Scale</div>
    </div>

    <div class="particle-count">
        Particles: <strong id="particleCount">5000</strong>
    </div>

    <!-- Import Maps for ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Global variables
        let scene, camera, renderer, particles;
        let targetPositions = [];
        let currentPositions = [];
        let velocities = [];
        const particleCount = 5000;
        let currentScale = 1.0;
        let targetScale = 1.0;
        let currentColor = new THREE.Color(0xa855f7);
        let targetColor = new THREE.Color(0xa855f7);
        let currentTemplate = 'heart';
        let handsDetected = { left: false, right: false };
        let handPositions = { left: null, right: null };
        let handTrackingActive = false;

        // Initialize Three.js scene
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createParticles();
            animate();

            window.addEventListener('resize', onWindowResize);
        }

        // Shape generation functions
        function generateHeartPositions(count) {
            const positions = [];
            for (let i = 0; i < count; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = Math.random();

                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                const z = (Math.random() - 0.5) * 2;

                positions.push(
                    x * 0.08 * (0.8 + r * 0.4),
                    y * 0.08 * (0.8 + r * 0.4),
                    z
                );
            }
            return new Float32Array(positions);
        }

        function generateFlowerPositions(count) {
            const positions = [];
            const petalCount = 6;

            for (let i = 0; i < count; i++) {
                const petal = Math.floor(Math.random() * petalCount);
                const angle = (petal / petalCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
                const r = Math.random() * 1.5 + 0.3;
                const petalShape = Math.cos(5 * angle) * 0.3 + 1;

                const x = Math.cos(angle) * r * petalShape;
                const y = Math.sin(angle) * r * petalShape;
                const z = (Math.random() - 0.5) * 0.5;

                positions.push(x, y, z);
            }
            return new Float32Array(positions);
        }

        function generateSaturnPositions(count) {
            const positions = [];
            const planetParticles = Math.floor(count * 0.4);
            const ringParticles = count - planetParticles;

            // Planet (sphere)
            for (let i = 0; i < planetParticles; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 0.6 * Math.pow(Math.random(), 0.3);

                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }

            // Rings
            for (let i = 0; i < ringParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 1.0 + Math.random() * 0.8;

                positions.push(
                    Math.cos(angle) * r,
                    (Math.random() - 0.5) * 0.05,
                    Math.sin(angle) * r * 0.3
                );
            }
            return new Float32Array(positions);
        }

        function generateBuddhaPositions(count) {
            const positions = [];

            for (let i = 0; i < count; i++) {
                const section = Math.random();
                let x, y, z;

                if (section < 0.25) {
                    // Head (sphere)
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 0.35;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta) + 1.2;
                    z = r * Math.cos(phi);
                } else if (section < 0.6) {
                    // Body (ellipsoid)
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const rx = 0.5;
                    const ry = 0.6;
                    const rz = 0.4;
                    x = rx * Math.sin(phi) * Math.cos(theta);
                    y = ry * Math.sin(phi) * Math.sin(theta) + 0.4;
                    z = rz * Math.cos(phi);
                } else if (section < 0.8) {
                    // Crossed legs base
                    const angle = Math.random() * Math.PI * 2;
                    const r = 0.3 + Math.random() * 0.4;
                    x = Math.cos(angle) * r;
                    y = -0.3 + (Math.random() - 0.5) * 0.2;
                    z = Math.sin(angle) * r * 0.5;
                } else {
                    // Aura/halo
                    const angle = Math.random() * Math.PI * 2;
                    const r = 1.2 + Math.random() * 0.3;
                    x = Math.cos(angle) * r;
                    y = 0.5 + Math.sin(angle) * r * 0.5;
                    z = (Math.random() - 0.5) * 0.1;
                }

                positions.push(x, y - 0.5, z);
            }
            return new Float32Array(positions);
        }

        function generateFireworkPositions(count) {
            const positions = [];
            const burstCount = 5;
            const particlesPerBurst = Math.floor(count / burstCount);

            for (let b = 0; b < burstCount; b++) {
                const centerX = (Math.random() - 0.5) * 2;
                const centerY = (Math.random() - 0.5) * 2;
                const centerZ = (Math.random() - 0.5);

                for (let i = 0; i < particlesPerBurst; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.random() * 0.8;

                    positions.push(
                        centerX + r * Math.sin(phi) * Math.cos(theta),
                        centerY + r * Math.sin(phi) * Math.sin(theta),
                        centerZ + r * Math.cos(phi)
                    );
                }
            }

            // Fill remaining particles
            while (positions.length < count * 3) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 0.5;
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }

            return new Float32Array(positions);
        }

        function generateStarPositions(count) {
            const positions = [];
            const points = 5;
            const outerRadius = 1.5;
            const innerRadius = 0.6;

            for (let i = 0; i < count; i++) {
                const random = Math.random();
                const pointIndex = Math.floor(Math.random() * points * 2);
                const isOuter = pointIndex % 2 === 0;
                const baseAngle = (pointIndex / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                const angleOffset = (Math.random() - 0.5) * (Math.PI / points);
                const angle = baseAngle + angleOffset;

                const baseR = isOuter ? outerRadius : innerRadius;
                const r = baseR * (0.7 + Math.random() * 0.6);

                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                const z = (Math.random() - 0.5) * 0.3;

                positions.push(x, y, z);
            }
            return new Float32Array(positions);
        }

        function getPositionsForTemplate(template) {
            switch (template) {
                case 'heart': return generateHeartPositions(particleCount);
                case 'flower': return generateFlowerPositions(particleCount);
                case 'saturn': return generateSaturnPositions(particleCount);
                case 'buddha': return generateBuddhaPositions(particleCount);
                case 'firework': return generateFireworkPositions(particleCount);
                case 'star': return generateStarPositions(particleCount);
                default: return generateHeartPositions(particleCount);
            }
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            targetPositions = getPositionsForTemplate(currentTemplate);
            currentPositions = new Float32Array(targetPositions.length);
            velocities = new Float32Array(targetPositions.length);

            // Initialize with random positions
            for (let i = 0; i < currentPositions.length; i++) {
                currentPositions[i] = (Math.random() - 0.5) * 10;
                velocities[i] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

            const material = new THREE.PointsMaterial({
                size: 0.03,
                color: currentColor,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updateParticles() {
            const positions = particles.geometry.attributes.position.array;
            const spring = 0.03;
            const damping = 0.85;

            for (let i = 0; i < positions.length; i += 3) {
                // Apply spring physics towards target
                const dx = targetPositions[i] * currentScale - positions[i];
                const dy = targetPositions[i + 1] * currentScale - positions[i + 1];
                const dz = targetPositions[i + 2] * currentScale - positions[i + 2];

                velocities[i] += dx * spring;
                velocities[i + 1] += dy * spring;
                velocities[i + 2] += dz * spring;

                velocities[i] *= damping;
                velocities[i + 1] *= damping;
                velocities[i + 2] *= damping;

                positions[i] += velocities[i];
                positions[i + 1] += velocities[i + 1];
                positions[i + 2] += velocities[i + 2];
            }

            particles.geometry.attributes.position.needsUpdate = true;

            // Smooth scale transition
            currentScale += (targetScale - currentScale) * 0.1;

            // Smooth color transition
            currentColor.lerp(targetColor, 0.1);
            particles.material.color = currentColor;

            // Gentle rotation
            particles.rotation.y += 0.002;
        }

        function changeTemplate(template) {
            currentTemplate = template;
            targetPositions = getPositionsForTemplate(template);

            // Add burst effect
            for (let i = 0; i < velocities.length; i++) {
                velocities[i] += (Math.random() - 0.5) * 0.5;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize MediaPipe Hands
        async function initHandTracking() {
            const videoElement = document.getElementById('video');
            const canvasElement = document.getElementById('handCanvas');
            const canvasCtx = canvasElement.getContext('2d');
            const statusElement = document.getElementById('camera-status');

            updateLoadingText('Requesting camera access...');

            try {
                // First get camera stream
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });

                videoElement.srcObject = stream;

                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        canvasElement.width = videoElement.videoWidth;
                        canvasElement.height = videoElement.videoHeight;
                        resolve();
                    };
                });

                statusElement.textContent = 'Camera active. Loading hand tracking...';
                updateLoadingText('Loading MediaPipe Hands model...');

                // Load MediaPipe Hands dynamically
                const handsModule = await import('https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js');

                const hands = new window.Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => onHandResults(results, canvasCtx, canvasElement));

                // Start detection loop
                async function detect() {
                    if (videoElement.readyState >= 2) {
                        await hands.send({ image: videoElement });
                    }
                    requestAnimationFrame(detect);
                }

                await hands.initialize();
                handTrackingActive = true;
                statusElement.textContent = '✓ Hand tracking active';
                statusElement.style.color = '#00ff88';
                document.getElementById('loading').classList.add('hidden');
                document.body.classList.add('stark-active');

                detect();

            } catch (err) {
                console.error('Hand tracking error:', err);
                statusElement.textContent = '⚠ Hand tracking unavailable';
                statusElement.style.color = '#f59e0b';
                document.getElementById('loading').classList.add('hidden');

                // Show helpful message
                setTimeout(() => {
                    statusElement.innerHTML = 'Use slider below ↓';
                }, 2000);
            }
        }

        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }

        function onHandResults(results, canvasCtx, canvasElement) {
            const leftHandEl = document.getElementById('left-hand');
            const rightHandEl = document.getElementById('right-hand');

            // Clear canvas
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            handsDetected = { left: false, right: false };
            handPositions = { left: null, right: null };

            if (results.multiHandLandmarks && results.multiHandedness) {
                results.multiHandedness.forEach((hand, index) => {
                    const landmarks = results.multiHandLandmarks[index];
                    const handType = hand.label.toLowerCase();

                    // Mirror the hand type since video is mirrored
                    const actualHand = handType === 'left' ? 'right' : 'left';
                    handsDetected[actualHand] = true;

                    // Get palm center (wrist landmark)
                    const palm = landmarks[0];
                    handPositions[actualHand] = { x: palm.x, y: palm.y };

                    // Draw hand landmarks
                    canvasCtx.fillStyle = actualHand === 'left' ? '#06b6d4' : '#ec4899';
                    landmarks.forEach(point => {
                        canvasCtx.beginPath();
                        canvasCtx.arc(
                            point.x * canvasElement.width,
                            point.y * canvasElement.height,
                            4, 0, 2 * Math.PI
                        );
                        canvasCtx.fill();
                    });

                    // Calculate hand openness (distance from wrist to fingertips average)
                    const fingertips = [4, 8, 12, 16, 20];
                    let avgDist = 0;
                    fingertips.forEach(tipIdx => {
                        const tip = landmarks[tipIdx];
                        const dx = tip.x - palm.x;
                        const dy = tip.y - palm.y;
                        avgDist += Math.sqrt(dx * dx + dy * dy);
                    });
                    avgDist /= fingertips.length;

                    handPositions[actualHand].openness = avgDist;
                });
            }

            // Update UI indicators
            leftHandEl.classList.toggle('active', handsDetected.left);
            rightHandEl.classList.toggle('active', handsDetected.right);

            // Calculate scale based on hand distance
            if (handsDetected.left && handsDetected.right) {
                const dx = handPositions.left.x - handPositions.right.x;
                const dy = handPositions.left.y - handPositions.right.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const avgOpenness = (handPositions.left.openness + handPositions.right.openness) / 2;
                targetScale = Math.max(0.3, Math.min(3.0, distance * 4 * (1 + avgOpenness)));

                document.getElementById('scaleValue').textContent = targetScale.toFixed(1) + 'x';
                document.getElementById('scaleSlider').value = targetScale;
            } else if (handsDetected.left || handsDetected.right) {
                const hand = handsDetected.left ? handPositions.left : handPositions.right;
                if (hand && hand.openness) {
                    targetScale = Math.max(0.5, Math.min(2.5, hand.openness * 8));
                    document.getElementById('scaleValue').textContent = targetScale.toFixed(1) + 'x';
                    document.getElementById('scaleSlider').value = targetScale;
                }
            }
        }

        // Event listeners for UI controls
        function initUIControls() {
            // Template buttons
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.template-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    changeTemplate(btn.dataset.template);
                });
            });

            // Color picker
            const colorPicker = document.getElementById('colorPicker');
            colorPicker.addEventListener('input', (e) => {
                targetColor = new THREE.Color(e.target.value);
                document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
            });

            // Color presets
            document.querySelectorAll('.color-preset').forEach(preset => {
                preset.addEventListener('click', () => {
                    const color = preset.dataset.color;
                    targetColor = new THREE.Color(color);
                    colorPicker.value = color;
                    document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
                    preset.classList.add('active');
                });
            });

            // Manual scale slider
            const scaleSlider = document.getElementById('scaleSlider');
            scaleSlider.addEventListener('input', (e) => {
                targetScale = parseFloat(e.target.value);
                document.getElementById('scaleValue').textContent = targetScale.toFixed(1) + 'x';
            });
        }

        // Make functions available globally for MediaPipe callback
        window.Hands = null;

        // Load MediaPipe script
        async function loadMediaPipe() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Initialize everything
        async function init() {
            initThree();
            initUIControls();

            try {
                await loadMediaPipe();
                await initHandTracking();
            } catch (err) {
                console.error('Failed to load hand tracking:', err);
                document.getElementById('loading').classList.add('hidden');
                document.body.classList.add('stark-active');
                document.getElementById('camera-status').textContent = 'Use slider for control';
            }
        }

        init();
    </script>
</body>

</html>